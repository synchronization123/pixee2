import os
import zipfile
import urllib.request
import shutil
import subprocess
import tempfile
import tkinter as tk
from tkinter import scrolledtext, ttk
import threading
import queue
import re
import winpty
import time

# ---------------- ANSI CLEANING & CONTEXT FILTER ----------------
ANSI_ESCAPE_RE = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
CONTEXT_RE = re.compile(r'(\d+)% context left')

def clean_terminal_output(text: str, filter_context: bool = True) -> str:
    if not text:
        return ""
    text = ANSI_ESCAPE_RE.sub("", text)
    text = text.replace("\r\n", "\n").replace("\r", "\n")
    if filter_context:
        lines = [line for line in text.split('\n') if not CONTEXT_RE.search(line)]
        text = '\n'.join(lines)
    return text + '\n'

# ---------------- USER HOME RESOLUTION ----------------
def resolve_user_home():
    username = os.getenv("USERNAME")
    candidates = []

    if username:
        candidates.append(fr"C:\Users\{username}")
        if not username.lower().endswith(".corp"):
            candidates.append(fr"C:\Users\{username}.corp")

    userprofile = os.getenv("USERPROFILE")
    if userprofile:
        candidates.append(userprofile)

    for path in dict.fromkeys(candidates):
        try:
            if path and os.path.isdir(path):
                test = os.path.join(path, ".perm_test")
                with open(test, "w") as f:
                    f.write("test")
                os.remove(test)
                return path
        except Exception:
            continue

    raise RuntimeError("Unable to determine writable user home")

USER_HOME = resolve_user_home()

# ---------------- FORCE CODEX HOME ----------------
CODEX_DIR = os.path.join(USER_HOME, ".codex")
CONFIG_PATH = os.path.join(CODEX_DIR, "config.toml")

# ---------------- TOOL PATHS ----------------
TOOLS_DIR = os.path.join(USER_HOME, "tools")
PYTHON_DIR = os.path.join(TOOLS_DIR, "python")
PYTHON_EXE = os.path.join(PYTHON_DIR, "python.exe")
NODE_DIR = os.path.join(TOOLS_DIR, "nodejs")

PYTHON_ZIP_URL = "https://www.python.org/ftp/python/3.12.2/python-3.12.2-embed-amd64.zip"
GET_PIP_URL = "https://bootstrap.pypa.io/get-pip.py"
NODE_ZIP_URL = "https://nodejs.org/dist/v24.12.0/node-v24.12.0-win-x64.zip"

# ---------------- SETUP GUI ----------------
class SetupGUI:
    def __init__(self, root):
        self.root = root
        root.title("Codex Setup & Chat (PowerShell)")
        root.geometry("900x650")

        self.log_box = scrolledtext.ScrolledText(root, wrap=tk.WORD)
        self.log_box.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.progress = ttk.Progressbar(root, mode="indeterminate")
        self.progress.pack(fill=tk.X, padx=10)

        self.status = tk.Label(root, text="Initializing...")
        self.status.pack(pady=5)

        self.q = queue.Queue()
        self.root.after(100, self.process_queue)

        threading.Thread(target=self.run, daemon=True).start()

    def log(self, msg):
        self.q.put(msg)

    def set_status(self, msg):
        self.q.put(f"[STATUS] {msg}")
        self.status.config(text=msg)

    def process_queue(self):
        try:
            while True:
                m = self.q.get_nowait()
                self.log_box.insert(tk.END, m + "\n")
                self.log_box.see(tk.END)
        except queue.Empty:
            pass
        self.root.after(100, self.process_queue)

    def ensure_python(self):
        if os.path.exists(PYTHON_EXE):
            self.log("‚úî Python already installed")
            return

        self.set_status("Installing Python...")
        os.makedirs(PYTHON_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(".zip")
        urllib.request.urlretrieve(PYTHON_ZIP_URL, zip_path)

        with zipfile.ZipFile(zip_path) as z:
            z.extractall(PYTHON_DIR)
        os.remove(zip_path)

        with open(os.path.join(PYTHON_DIR, "python312._pth"), "a") as f:
            f.write("\nimport site\n")

        get_pip = tempfile.mktemp(".py")
        urllib.request.urlretrieve(GET_PIP_URL, get_pip)
        subprocess.run([PYTHON_EXE, get_pip], check=True)

        self.log("‚úî Python + pip installed")

    def ensure_node(self):
        if os.path.exists(os.path.join(NODE_DIR, "node.exe")):
            self.log("‚úî Node.js already installed")
            return

        self.set_status("Installing Node.js...")
        os.makedirs(TOOLS_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(".zip")
        urllib.request.urlretrieve(NODE_ZIP_URL, zip_path)

        with zipfile.ZipFile(zip_path) as z:
            z.extractall(TOOLS_DIR)
        os.remove(zip_path)

        extracted = next(d for d in os.listdir(TOOLS_DIR) if d.startswith("node-v"))
        shutil.move(os.path.join(TOOLS_DIR, extracted), NODE_DIR)

        self.log("‚úî Node.js installed")

    def ensure_codex(self):
        self.set_status("Installing Codex...")
        npm = os.path.join(NODE_DIR, "npm.cmd")

        env = os.environ.copy()
        env["PATH"] = NODE_DIR + ";" + env["PATH"]
        env["CODEX_HOME"] = CODEX_DIR
        env["USERPROFILE"] = USER_HOME

        subprocess.run([npm, "config", "set", "prefix", NODE_DIR], env=env, check=True)
        subprocess.run([npm, "install", "-g", "@openai/codex"], env=env, check=True)

        self.log("‚úî Codex installed")

    def run(self):
        self.progress.start()
        self.ensure_python()
        self.ensure_node()
        self.ensure_codex()
        self.progress.stop()
        self.set_status("Setup complete")

        tk.Button(
            self.root,
            text="Open Codex Chat",
            font=("Segoe UI", 11, "bold"),
            command=self.open_chat
        ).pack(pady=10)

    def open_chat(self):
        ChatWindow(self.root)

# ---------------- CHAT WINDOW ----------------
class ChatWindow:
    def __init__(self, parent):
        self.win = tk.Toplevel(parent)
        self.win.title("Codex Interactive Chat")
        self.win.geometry("800x550")

        self.output = scrolledtext.ScrolledText(self.win, wrap=tk.WORD, state=tk.DISABLED)
        self.output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        input_frame = tk.Frame(self.win)
        input_frame.pack(fill=tk.X, padx=10, pady=5)

        self.prompt = tk.Entry(input_frame)
        self.prompt.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.prompt.bind("<Return>", self.send_prompt)

        tk.Button(input_frame, text="Ask Codex", command=self.send_prompt).pack(side=tk.RIGHT)

        self.pty = None
        self.codex_ready = False
        self.pending_queue = []

        self.start_pty()
        threading.Thread(target=self.read_output, daemon=True).start()

    def start_pty(self):
        env = {
            **os.environ,
            "CODEX_HOME": CODEX_DIR,
            "USERPROFILE": USER_HOME
        }

        self.pty = winpty.PtyProcess.spawn(
            ["powershell.exe", "-NoLogo", "-NoExit"],
            cwd=CODEX_DIR,
            env=env
        )

        threading.Timer(0.5, lambda: self.safe_write("codex\r\n")).start()

    def safe_write(self, text):
        try:
            if self.pty:
                self.pty.write(text)
        except Exception:
            pass

    def insert_output(self, text):
        self.output.config(state=tk.NORMAL)
        self.output.insert(tk.END, text)
        self.output.see(tk.END)
        self.output.config(state=tk.DISABLED)

    def send_prompt(self, event=None):
        query = self.prompt.get().strip()
        if not query:
            return

        self.prompt.delete(0, tk.END)
        self.insert_output(f"\nüßë You: {query}\n")

        if not self.codex_ready:
            self.pending_queue.append(query)
        else:
            self.safe_write(query + "\r\n")

    def read_output(self):
        while True:
            try:
                data = self.pty.read(4096)
                if not data:
                    continue

                text = data if isinstance(data, str) else data.decode(errors="ignore")

                if "Compose is empty" in text or ">" in text:
                    self.codex_ready = True
                    while self.pending_queue:
                        self.safe_write(self.pending_queue.pop(0) + "\r\n")

                cleaned = clean_terminal_output(text)
                if cleaned.strip():
                    self.insert_output(cleaned)

            except Exception as e:
                self.insert_output(f"\n‚ùå Error: {e}\n")
                break

# ---------------- ENTRY ----------------
if __name__ == "__main__":
    root = tk.Tk()
    SetupGUI(root)
    root.mainloop()
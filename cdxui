import os
import zipfile
import urllib.request
import shutil
import subprocess
import tempfile
import tkinter as tk
from tkinter import scrolledtext, ttk
import threading
import queue
import time

# ---------------- USER HOME RESOLUTION ----------------
def resolve_user_home():
    username = os.getenv("USERNAME")
    candidates = []

    if username:
        candidates.append(fr"C:\Users\{username}")
        if username.lower().endswith(".corp"):
            candidates.append(fr"C:\Users\{username[:-5]}")

    userprofile = os.getenv("USERPROFILE")
    if userprofile:
        candidates.append(userprofile)

    for path in candidates:
        try:
            if path and os.path.isdir(path):
                test = os.path.join(path, ".perm_test")
                with open(test, "w") as f:
                    f.write("test")
                os.remove(test)
                return path
        except Exception:
            continue

    raise RuntimeError("Unable to determine writable user home")

USER_HOME = resolve_user_home()

# ---------------- PATHS ----------------
TOOLS_DIR = os.path.join(USER_HOME, "tools")
PYTHON_DIR = os.path.join(TOOLS_DIR, "python")
PYTHON_EXE = os.path.join(PYTHON_DIR, "python.exe")
NODE_DIR = os.path.join(TOOLS_DIR, "nodejs")
WINPTY_DIR = os.path.join(TOOLS_DIR, "winpty")

CODEX_DIR = os.path.join(USER_HOME, ".codex")
CONFIG_PATH = os.path.join(CODEX_DIR, "config.toml")

PYTHON_ZIP_URL = "https://www.python.org/ftp/python/3.12.2/python-3.12.2-embed-amd64.zip"
GET_PIP_URL = "https://bootstrap.pypa.io/get-pip.py"
NODE_ZIP_URL = "https://nodejs.org/dist/v24.12.0/node-v24.12.0-win-x64.zip"
WINPTY_ZIP_URL = "https://github.com/rprichard/winpty/releases/download/0.4.3/winpty-0.4.3-msvc2015.zip"

# ---------------- RESOLVE CODEX ----------------
def resolve_codex_cmd():
    candidates = [
        os.path.join(NODE_DIR, "codex.cmd"),
        os.path.join(NODE_DIR, "bin", "codex.cmd"),
        os.path.join(NODE_DIR, "node_modules", ".bin", "codex.cmd"),
    ]
    for c in candidates:
        if os.path.exists(c):
            return c
    raise FileNotFoundError("codex.cmd not found")

# ---------------- GUI ----------------
class SetupGUI:
    def __init__(self, root):
        self.root = root
        root.title("Codex Interactive GUI (No Terminal)")
        root.geometry("900x650")

        self.log_box = scrolledtext.ScrolledText(root)
        self.log_box.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.progress = ttk.Progressbar(root, mode="indeterminate")
        self.progress.pack(fill=tk.X, padx=10)

        self.status = tk.Label(root, text="Initializing...")
        self.status.pack(pady=5)

        self.q = queue.Queue()
        self.root.after(100, self.process_queue)

        threading.Thread(target=self.run, daemon=True).start()

    def log(self, msg):
        self.q.put(msg)

    def set_status(self, msg):
        self.q.put(msg)
        self.status.config(text=msg)

    def process_queue(self):
        try:
            while True:
                self.log_box.insert(tk.END, self.q.get_nowait() + "\n")
                self.log_box.see(tk.END)
        except queue.Empty:
            pass
        self.root.after(100, self.process_queue)

    # ---------- SETUP ----------
    def ensure_winpty(self):
        if os.path.exists(os.path.join(WINPTY_DIR, "bin", "winpty.exe")):
            self.log("✔ winpty already installed")
            return

        self.set_status("Installing winpty...")
        os.makedirs(WINPTY_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(".zip")
        urllib.request.urlretrieve(WINPTY_ZIP_URL, zip_path)

        with zipfile.ZipFile(zip_path) as z:
            z.extractall(WINPTY_DIR)

        os.remove(zip_path)
        self.log("✔ winpty installed")

    def run(self):
        self.progress.start()

        self.ensure_winpty()

        self.progress.stop()
        self.set_status("Ready")

        tk.Button(
            self.root,
            text="Open Codex Chat",
            font=("Segoe UI", 11, "bold"),
            command=self.open_chat
        ).pack(pady=10)

    def open_chat(self):
        ChatWindow(self.root)

# ---------------- INTERACTIVE CHAT ----------------
class ChatWindow:
    def __init__(self, parent):
        self.codex_cmd = resolve_codex_cmd()
        self.winpty = os.path.join(WINPTY_DIR, "bin", "winpty.exe")

        self.win = tk.Toplevel(parent)
        self.win.title("Codex Interactive Session")
        self.win.geometry("800x550")

        self.output = scrolledtext.ScrolledText(self.win)
        self.output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.entry = tk.Entry(self.win)
        self.entry.pack(fill=tk.X, padx=10, pady=5)
        self.entry.focus()

        self.entry.bind("<Return>", self.send)

        self.proc = subprocess.Popen(
            [self.winpty, self.codex_cmd],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )

        threading.Thread(target=self.read_output, daemon=True).start()

    def read_output(self):
        for line in self.proc.stdout:
            self.output.insert(tk.END, line)
            self.output.see(tk.END)

    def send(self, event=None):
        text = self.entry.get().strip()
        if not text:
            return
        self.entry.delete(0, tk.END)
        self.proc.stdin.write(text + "\n")
        self.proc.stdin.flush()

# ---------------- ENTRY ----------------
if __name__ == "__main__":
    root = tk.Tk()
    SetupGUI(root)
    root.mainloop()
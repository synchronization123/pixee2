import os
import zipfile
import urllib.request
import shutil
import subprocess
import tempfile
import tkinter as tk
from tkinter import scrolledtext, ttk, messagebox
import threading
import queue
import re
import winpty  # ConPTY support (required)
import time  # For cooldowns
import socket  # For error checking

# ---------------- ANSI CLEANING & CONTEXT FILTER ----------------
ANSI_ESCAPE_RE = re.compile(r"\u001B(?:[@-Z\\-_]|[[0-?]*[ -/]*[@-~])")
CONTEXT_RE = re.compile(r'(d+)% context left')

def clean_terminal_output(text: str, filter_context: bool = True) -> str:
    if not text:
        return ""
    text = ANSI_ESCAPE_RE.sub("", text)
    text = text.replace("
", "
").replace("
", "
")
    if filter_context:
        # Filter out lines containing "% context left" to reduce spam in display
        lines = [line for line in text.split('
') if not CONTEXT_RE.search(line)]
        text = '
'.join(lines)
    return text.strip() + '
'  # Ensure trailing newline for clean insertion

# ---------------- USER HOME RESOLUTION ----------------
def resolve_user_home():
    username = os.getenv("USERNAME")
    candidates = []

    if username:
        candidates.append(fr"C:Users{username}")
        if not username.lower().endswith(".corp"):
            candidates.append(fr"C:Users{username}.corp")

    userprofile = os.getenv("USERPROFILE")
    if userprofile:
        candidates.append(userprofile)

    for path in dict.fromkeys(candidates):
        try:
            if path and os.path.isdir(path):
                test = os.path.join(path, ".perm_test")
                with open(test, "w") as f:
                    f.write("test")
                os.remove(test)
                return path
        except Exception:
            continue

    raise RuntimeError("Unable to determine writable user home")

USER_HOME = resolve_user_home()

# ---------------- FORCE CODEX HOME ----------------
CODEX_DIR = os.path.join(USER_HOME, ".codex")
CONFIG_PATH = os.path.join(CODEX_DIR, "config.toml")

# ---------------- TOOL PATHS ----------------
TOOLS_DIR = os.path.join(USER_HOME, "tools")
PYTHON_DIR = os.path.join(TOOLS_DIR, "python")
PYTHON_EXE = os.path.join(PYTHON_DIR, "python.exe")
NODE_DIR = os.path.join(TOOLS_DIR, "nodejs")

PYTHON_ZIP_URL = "https://www.python.org/ftp/python/3.12.2/python-3.12.2-embed-amd64.zip"
GET_PIP_URL = "https://bootstrap.pypa.io/get-pip.py"
NODE_ZIP_URL = "https://nodejs.org/dist/v24.12.0/node-v24.12.0-win-x64.zip"

# ---------------- SETUP GUI ----------------
class SetupGUI:
    def __init__(self, root):
        self.root = root
        root.title("Codex Setup & Chat (PowerShell)")
        root.geometry("900x650")

        self.log_box = scrolledtext.ScrolledText(root, wrap=tk.WORD)
        self.log_box.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.progress = ttk.Progressbar(root, mode="indeterminate")
        self.progress.pack(fill=tk.X, padx=10)

        self.status = tk.Label(root, text="Initializing...")
        self.status.pack(pady=5)

        self.q = queue.Queue()
        self.root.after(100, self.process_queue)

        threading.Thread(target=self.run, daemon=True).start()

    def log(self, msg):
        self.q.put(msg)

    def set_status(self, msg):
        self.q.put(f"[STATUS] {msg}")
        self.root.after(0, lambda: self.status.config(text=msg))

    def process_queue(self):
        try:
            while True:
                m = self.q.get_nowait()
                self.root.after(0, lambda msg=m: self.log_box.insert(tk.END, msg + "
") or self.log_box.see(tk.END))
        except queue.Empty:
            pass
        self.root.after(100, self.process_queue)

    def ensure_python(self):
        if os.path.exists(PYTHON_EXE):
            self.log("‚úî Python already installed")
            return

        self.set_status("Installing Python...")
        os.makedirs(PYTHON_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(suffix=".zip")
        urllib.request.urlretrieve(PYTHON_ZIP_URL, zip_path)

        try:
            with zipfile.ZipFile(zip_path) as z:
                z.extractall(PYTHON_DIR)
            
            # Fix python312._pth file
            pth_file = os.path.join(PYTHON_DIR, "python312._pth")
            with open(pth_file, "a", encoding='utf-8') as f:
                f.write("
import site
")

            # Install pip
            get_pip = tempfile.mktemp(suffix=".py")
            urllib.request.urlretrieve(GET_PIP_URL, get_pip)
            subprocess.run([PYTHON_EXE, get_pip], check=True, capture_output=True)
            os.remove(get_pip)
            
            self.log("‚úî Python + pip installed")
        finally:
            if os.path.exists(zip_path):
                os.remove(zip_path)

    def ensure_node(self):
        node_exe = os.path.join(NODE_DIR, "node.exe")
        if os.path.exists(node_exe):
            self.log("‚úî Node.js already installed")
            return

        self.set_status("Installing Node.js...")
        os.makedirs(TOOLS_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(suffix=".zip")
        try:
            urllib.request.urlretrieve(NODE_ZIP_URL, zip_path)

            with zipfile.ZipFile(zip_path) as z:
                z.extractall(TOOLS_DIR)
            
            # Find and move extracted folder
            for item in os.listdir(TOOLS_DIR):
                if item.startswith("node-v"):
                    src = os.path.join(TOOLS_DIR, item)
                    shutil.move(src, NODE_DIR)
                    break
            
            self.log("‚úî Node.js installed")
        finally:
            if os.path.exists(zip_path):
                os.remove(zip_path)

    def ensure_codex(self):
        self.set_status("Installing Codex...")
        npm = os.path.join(NODE_DIR, "npm.cmd")
        node_exe = os.path.join(NODE_DIR, "node.exe")

        env = os.environ.copy()
        env["PATH"] = f"{NODE_DIR};{env.get('PATH', '')}"
        env["CODEX_HOME"] = CODEX_DIR
        env["USERPROFILE"] = USER_HOME

        try:
            subprocess.run([npm, "config", "set", "prefix", NODE_DIR], 
                         env=env, check=True, capture_output=True)
            subprocess.run([npm, "install", "-g", "@openai/codex"], 
                         env=env, check=True, capture_output=True)
            
            # Verify installation
            version_result = subprocess.run([node_exe, "-e", 
                "console.log(require.resolve('@openai/codex/package.json') ? require('@openai/codex/package.json').version : 'unknown')"], 
                capture_output=True, text=True, env=env)
            version = version_result.stdout.strip()
            self.log(f"‚úî Codex installed (v{version})")
        except subprocess.CalledProcessError as e:
            self.log(f"‚úî Codex installed (with warnings: {e})")
        except Exception as e:
            self.log(f"‚úî Codex installed (version check failed: {e})")

    def ensure_config(self):
        os.makedirs(CODEX_DIR, exist_ok=True)
        config_content = """# Codex CLI Config - Reduced Output
[features]
hide_agent_reasoning = true
model_reasoning_summary = "none"

[tui]
animations = false
notifications = false
"""
        with open(CONFIG_PATH, "w", encoding='utf-8') as f:
            f.write(config_content)
        self.log(f"‚úî config.toml ready at {CONFIG_PATH}")

    def run(self):
        self.progress.start()
        try:
            self.ensure_python()
            self.ensure_node()
            self.ensure_codex()
            self.ensure_config()
            self.set_status("Setup complete! Ready to chat.")
        except Exception as e:
            self.log(f"‚ùå Setup error: {e}")
            self.set_status(f"Setup failed: {e}")
        finally:
            self.progress.stop()
        
        self.root.after(0, lambda: tk.Button(
            self.root, text="Open Codex Chat", font=("Segoe UI", 11, "bold"),
            command=self.open_chat).pack(pady=10))

    def open_chat(self):
        ChatWindow(self.root)

# ---------------- CHAT WINDOW (POWERSHELL HOST) ----------------
class ChatWindow:
    def __init__(self, parent):
        self.win = tk.Toplevel(parent)
        self.win.title("Codex Interactive Chat (PowerShell)")
        self.win.geometry("900x650")
        self.win.protocol("WM_DELETE_WINDOW", self.on_closing)

        self.output = scrolledtext.ScrolledText(self.win, wrap=tk.WORD, state=tk.DISABLED)
        self.output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Command buttons frame
        button_frame = tk.Frame(self.win)
        button_frame.pack(fill=tk.X, padx=10, pady=5)

        tk.Button(button_frame, text="Compact (/compact)", 
                 command=lambda: self.send_command('/compact')).pack(side=tk.LEFT, padx=(0, 5))
        tk.Button(button_frame, text="Clear (/clear)", 
                 command=lambda: self.send_command('/clear')).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="New Session (/new)", 
                 command=lambda: self.send_command('/new')).pack(side=tk.LEFT, padx=5)

        # Background mode toggle
        self.bg_mode = tk.BooleanVar(value=False)
        self.bg_check = tk.Checkbutton(button_frame, text="Background PS Mode", 
                                     variable=self.bg_mode, command=self.restart_pty)
        self.bg_check.pack(side=tk.LEFT, padx=5)

        # Input frame
        input_frame = tk.Frame(self.win)
        input_frame.pack(fill=tk.X, padx=10, pady=5)

        self.prompt = tk.Entry(input_frame)
        self.prompt.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.prompt.focus()
        self.prompt.bind('<Return>', self.send_prompt)

        tk.Button(input_frame, text="Ask Codex", command=self.send_prompt).pack(side=tk.RIGHT)

        # Context status label
        self.context_label = tk.Label(self.win, text="Context: Ready", fg="gray")
        self.context_label.pack(pady=(5, 0))

        self.pty = None
        self.read_thread = None
        self.current_context = 100
        self.output_buffer = ""
        self.auto_compact_threshold = 20
        self.critical_restart_threshold = 5
        self.last_auto_time = 0
        self.cooldown = 30
        self._compacting = False
        self._restarting = False

        self.win.after(100, self.restart_pty)

    def on_closing(self):
        if self.pty:
            try:
                self.pty.close()
            except:
                pass
        self.win.destroy()

    def insert_output(self, text):
        def _insert():
            self.output.config(state=tk.NORMAL)
            self.output.insert(tk.END, text)
            self.output.see(tk.END)
            self.output.config(state=tk.DISABLED)
        self.win.after(0, _insert)

    def update_context_status(self, percentage):
        def _update():
            if abs(percentage - self.current_context) > 1:
                color = "red" if percentage < 20 else "orange" if percentage < 40 else "green"
                self.context_label.config(text=f"Context: {percentage}%", fg=color)
                self.current_context = percentage
        self.win.after(0, _update)

    def send_command(self, cmd):
        if not self.pty or not self.pty.isalive():
            messagebox.showwarning("Warning", "PTY not active. Restarting...")
            self.restart_pty()
            return
        self.insert_output(f"
[Command] {cmd}
")
        self.pty.write(cmd + '
')

    def send_prompt(self, event=None):
        query = self.prompt.get().strip()
        if not query:
            return
        if not self.pty or not self.pty.isalive():
            messagebox.showwarning("Warning", "PTY not active. Restarting...")
            self.restart_pty()
            return

        self.insert_output(f"
üßë You: {query}
")
        self.prompt.delete(0, tk.END)
        self.pty.write(query + '
')

    def restart_pty(self):
        # Cleanup existing
        if self.pty:
            try:
                self.pty.close()
            except:
                pass
        if self.read_thread and self.read_thread.is_alive():
            self.read_thread = None  # Let it die naturally

        self.insert_output("
[Restart] Reloading PTY session...
")

        env = {
            **os.environ,
            "CODEX_HOME": CODEX_DIR,
            "USERPROFILE": USER_HOME,
        }

        try:
            if self.bg_mode.get():
                self.pty = winpty.PtyProcess.spawn(
                    ["powershell.exe", "-NoLogo", "-NoExit"],
                    cwd=CODEX_DIR,
                    env=env
                )
                self.win.after(500, lambda: self.pty.write("codex
") if self.pty and self.pty.isalive() else None)
                self.insert_output("[BG Mode] Started PowerShell + Codex...
")
            else:
                self.pty = winpty.PtyProcess.spawn(
                    ["powershell.exe", "-NoLogo", "-NoExit", "-Command", "codex"],
                    cwd=CODEX_DIR,
                    env=env
                )
                self.insert_output("[Direct Mode] Launched Codex CLI...
")
        except Exception as e:
            self.insert_output(f"
‚ùå Failed to start PTY: {e}
")
            return

        # Start read thread
        self.read_thread = threading.Thread(target=self.read_output, daemon=True)
        self.read_thread.start()

    def read_output(self):
        consecutive_errors = 0
        max_consecutive = 3
        
        while self.pty and self.pty.isalive() and self.read_thread == threading.current_thread():
            try:
                data = self.pty.read(4096)
                if not data:
                    time.sleep(0.1)
                    continue

                consecutive_errors = 0

                # Handle both str and bytes
                if isinstance(data, bytes):
                    text = data.decode('utf-8', errors='ignore')
                else:
                    text = str(data)

                # Parse context percentage
                match = CONTEXT_RE.search(text)
                if match:
                    percentage = int(match.group(1))
                    self.update_context_status(percentage)
                    
                    now = time.time()
                    if (percentage < self.auto_compact_threshold and 
                        percentage < self.current_context and 
                        now - self.last_auto_time > self.cooldown and 
                        not self._compacting):
                        
                        self._compacting = True
                        self.last_auto_time = now
                        self.insert_output(f"
[Auto] Context low ({percentage}%) - Sending /compact...
")
                        if self.pty and self.pty.isalive():
                            self.pty.write('/compact
')
                        self.win.after(5000, lambda: setattr(self, '_compacting', False))
                        
                    elif (percentage < self.critical_restart_threshold and 
                          now - self.last_auto_time > self.cooldown * 2 and 
                          not self._restarting):
                        
                        self._restarting = True
                        self.last_auto_time = now
                        self.insert_output(f"
[Critical] Context critically low ({percentage}%) - Restarting...
")
                        if self.pty and self.pty.isalive():
                            self.pty.write('/new
')
                        self.win.after(10000, lambda: setattr(self, '_restarting', False))

                # Clean and display
                cleaned = clean_terminal_output(text, filter_context=True)
                if cleaned.strip():
                    self.output_buffer += cleaned
                    self.insert_output(cleaned)
                    if len(self.output_buffer) > 10000:
                        self.output_buffer = self.output_buffer[-5000:]

            except socket.error as e:
                if hasattr(e, 'errno') and e.errno == 10053:
                    consecutive_errors += 1
                    self.insert_output(f"
[Conn Abort #{consecutive_errors}] Retrying...
")
                    if consecutive_errors >= max_consecutive:
                        self.insert_output("
[Restart] Auto-restarting PTY...
")
                        self.win.after(0, self.restart_pty)
                        break
                    time.sleep(1)
                else:
                    self.insert_output(f"
‚ùå Socket error: {e}
")
                    break
            except Exception as e:
                self.insert_output(f"
‚ùå Read error: {e}
")
                time.sleep(1)

# ---------------- ENTRY ----------------
if __name__ == "__main__":
    root = tk.Tk()
    app = SetupGUI(root)
    root.mainloop()
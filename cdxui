import os
import zipfile
import urllib.request
import shutil
import subprocess
import tempfile
import tkinter as tk
from tkinter import scrolledtext, ttk, messagebox
import threading
import queue
import re
import winpty  # ConPTY support (required)
import time  # For cooldowns
import socket  # For error checking

# ---------------- ANSI CLEANING & CONTEXT FILTER ----------------
ANSI_ESCAPE_RE = re.compile(r"\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])")
CONTEXT_RE = re.compile(r'(\d+)% context left')

def clean_terminal_output(text: str, filter_context: bool = True) -> str:
    if not text:
        return ""
    text = ANSI_ESCAPE_RE.sub("", text)
    text = text.replace("\r\n", "\n").replace("\r", "\n")
    if filter_context:
        lines = [line for line in text.split('\n') if not CONTEXT_RE.search(line)]
        text = '\n'.join(lines)
    return text.strip() + '\n'

# ---------------- USER HOME RESOLUTION ----------------
def resolve_user_home():
    username = os.getenv("USERNAME")
    candidates = []

    if username:
        candidates.append(fr"C:\Users\{username}")
        if not username.lower().endswith(".corp"):
            candidates.append(fr"C:\Users\{username}.corp")

    userprofile = os.getenv("USERPROFILE")
    if userprofile:
        candidates.append(userprofile)

    for path in dict.fromkeys(candidates):
        try:
            if path and os.path.isdir(path):
                test = os.path.join(path, ".perm_test")
                with open(test, "w") as f:
                    f.write("test")
                os.remove(test)
                return path
        except Exception:
            continue

    raise RuntimeError("Unable to determine writable user home")

USER_HOME = resolve_user_home()

# ---------------- FORCE CODEX HOME ----------------
CODEX_DIR = os.path.join(USER_HOME, ".codex")
CONFIG_PATH = os.path.join(CODEX_DIR, "config.toml")

# ---------------- TOOL PATHS ----------------
TOOLS_DIR = os.path.join(USER_HOME, "tools")
PYTHON_DIR = os.path.join(TOOLS_DIR, "python")
PYTHON_EXE = os.path.join(PYTHON_DIR, "python.exe")
NODE_DIR = os.path.join(TOOLS_DIR, "nodejs")

PYTHON_ZIP_URL = "https://www.python.org/ftp/python/3.12.2/python-3.12.2-embed-amd64.zip"
GET_PIP_URL = "https://bootstrap.pypa.io/get-pip.py"
NODE_ZIP_URL = "https://nodejs.org/dist/v24.12.0/node-v24.12.0-win-x64.zip"

# ---------------- SETUP GUI ----------------
class SetupGUI:
    def __init__(self, root):
        self.root = root
        root.title("Codex Setup & Chat (PowerShell)")
        root.geometry("900x650")

        self.log_box = scrolledtext.ScrolledText(root, wrap=tk.WORD)
        self.log_box.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.progress = ttk.Progressbar(root, mode="indeterminate")
        self.progress.pack(fill=tk.X, padx=10)

        self.status = tk.Label(root, text="Initializing...")
        self.status.pack(pady=5)

        self.q = queue.Queue()
        self.root.after(100, self.process_queue)

        threading.Thread(target=self.run, daemon=True).start()

    def log(self, msg):
        self.q.put(msg)

    def set_status(self, msg):
        self.q.put(f"[STATUS] {msg}")
        self.status.config(text=msg)

    def process_queue(self):
        try:
            while True:
                m = self.q.get_nowait()
                self.log_box.insert(tk.END, m + "\n")
                self.log_box.see(tk.END)
        except queue.Empty:
            pass
        self.root.after(100, self.process_queue)

    def ensure_python(self):
        if os.path.exists(PYTHON_EXE):
            self.log("✔ Python already installed")
            return

        self.set_status("Installing Python...")
        os.makedirs(PYTHON_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(".zip")
        urllib.request.urlretrieve(PYTHON_ZIP_URL, zip_path)

        with zipfile.ZipFile(zip_path) as z:
            z.extractall(PYTHON_DIR)
        os.remove(zip_path)

        with open(os.path.join(PYTHON_DIR, "python312._pth"), "a") as f:
            f.write("\nimport site\n")

        get_pip = tempfile.mktemp(".py")
        urllib.request.urlretrieve(GET_PIP_URL, get_pip)
        subprocess.run([PYTHON_EXE, get_pip], check=True)

        self.log("✔ Python + pip installed")

    def ensure_node(self):
        if os.path.exists(os.path.join(NODE_DIR, "node.exe")):
            self.log("✔ Node.js already installed")
            return

        self.set_status("Installing Node.js...")
        os.makedirs(TOOLS_DIR, exist_ok=True)

        zip_path = tempfile.mktemp(".zip")
        urllib.request.urlretrieve(NODE_ZIP_URL, zip_path)

        with zipfile.ZipFile(zip_path) as z:
            z.extractall(TOOLS_DIR)
        os.remove(zip_path)

        extracted = next(d for d in os.listdir(TOOLS_DIR) if d.startswith("node-v"))
        shutil.move(os.path.join(TOOLS_DIR, extracted), NODE_DIR)

        self.log("✔ Node.js installed")

    def ensure_codex(self):
        self.set_status("Installing Codex...")
        npm = os.path.join(NODE_DIR, "npm.cmd")

        env = os.environ.copy()
        env["PATH"] = NODE_DIR + ";" + env["PATH"]
        env["CODEX_HOME"] = CODEX_DIR
        env["USERPROFILE"] = USER_HOME

        subprocess.run([npm, "config", "set", "prefix", NODE_DIR], env=env, check=True)
        subprocess.run([npm, "install", "-g", "@openai/codex"], env=env, check=True)

        self.log("✔ Codex installed")

    def ensure_config(self):
        # ❗ DO NOT TOUCH config.toml
        # Only ensure directory exists
        os.makedirs(CODEX_DIR, exist_ok=True)
        self.log("✔ config.toml left unchanged")

    def run(self):
        self.progress.start()
        self.ensure_python()
        self.ensure_node()
        self.ensure_codex()
        self.ensure_config()
        self.progress.stop()
        self.set_status("Setup complete! Using ~/.codex as-is.")

        tk.Button(
            self.root,
            text="Open Codex Chat",
            font=("Segoe UI", 11, "bold"),
            command=self.open_chat
        ).pack(pady=10)

    def open_chat(self):
        ChatWindow(self.root)

# ---------------- CHAT WINDOW ----------------
class ChatWindow:
    def __init__(self, parent):
        self.win = tk.Toplevel(parent)
        self.win.title("Codex Interactive Chat (PowerShell)")
        self.win.geometry("800x550")

        self.output = scrolledtext.ScrolledText(self.win, wrap=tk.WORD, state=tk.DISABLED)
        self.output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        self.prompt = tk.Entry(self.win)
        self.prompt.pack(fill=tk.X, padx=10, pady=5)
        self.prompt.bind('<Return>', lambda e: self.send_prompt())

        tk.Button(self.win, text="Ask Codex", command=self.send_prompt).pack(pady=5)

        self.pty = None
        self.restart_pty()

    def restart_pty(self):
        env = {
            **os.environ,
            "CODEX_HOME": CODEX_DIR,
            "USERPROFILE": USER_HOME,
        }
        self.pty = winpty.PtyProcess.spawn(
            ["powershell.exe", "-NoLogo", "-NoExit", "-Command", "codex"],
            cwd=CODEX_DIR,
            env=env
        )
        threading.Thread(target=self.read_output, daemon=True).start()

    def send_prompt(self):
        text = self.prompt.get().strip()
        if text:
            self.prompt.delete(0, tk.END)
            self.pty.write(text + "\r\n")

    def read_output(self):
        while True:
            try:
                data = self.pty.read(4096)
                if data:
                    cleaned = clean_terminal_output(data)
                    self.output.config(state=tk.NORMAL)
                    self.output.insert(tk.END, cleaned)
                    self.output.see(tk.END)
                    self.output.config(state=tk.DISABLED)
            except:
                break

# ---------------- ENTRY ----------------
if __name__ == "__main__":
    root = tk.Tk()
    SetupGUI(root)
    root.mainloop()
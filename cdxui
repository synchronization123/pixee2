import os
import zipfile
import urllib.request
import shutil
import subprocess
import tempfile
import tkinter as tk
from tkinter import scrolledtext, ttk, messagebox
import threading
import queue
import datetime
import json

# =========================================================
# USER HOME
# =========================================================
def resolve_user_home():
    for var in ("USERPROFILE",):
        p = os.getenv(var)
        if p and os.path.isdir(p):
            return p
    raise RuntimeError("Cannot resolve user home")

USER_HOME = resolve_user_home()

# =========================================================
# PATHS
# =========================================================
TOOLS_DIR = os.path.join(USER_HOME, "tools")
PYTHON_DIR = os.path.join(TOOLS_DIR, "python")
NODE_DIR = os.path.join(TOOLS_DIR, "nodejs")
CODEX_CMD = os.path.join(NODE_DIR, "codex.cmd")

CODEX_DIR = os.path.join(USER_HOME, ".codex")
CHAT_DIR = os.path.join(CODEX_DIR, "chat_history")
MEMORY_FILE = os.path.join(CODEX_DIR, "long_term_memory.json")
TEMPLATE_DIR = os.path.join(CODEX_DIR, "prompt_templates")

for d in (CODEX_DIR, CHAT_DIR, TEMPLATE_DIR):
    os.makedirs(d, exist_ok=True)

CREATE_NO_WINDOW = 0x08000000

# =========================================================
# MEMORY
# =========================================================
def load_memory():
    if os.path.exists(MEMORY_FILE):
        with open(MEMORY_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return []

def save_memory(mem):
    with open(MEMORY_FILE, "w", encoding="utf-8") as f:
        json.dump(mem[-50:], f, indent=2)

LONG_TERM_MEMORY = load_memory()

# =========================================================
# LOAD MD TEMPLATES
# =========================================================
def load_templates():
    t = {"Free Chat": ""}
    for f in os.listdir(TEMPLATE_DIR):
        if f.endswith(".md"):
            with open(os.path.join(TEMPLATE_DIR, f), encoding="utf-8") as fh:
                t[f[:-3]] = fh.read()
    return t

# =========================================================
# CHAT SESSION
# =========================================================
class ChatSession:
    def __init__(self):
        self.history = []
        self.file = os.path.join(
            CHAT_DIR,
            f"chat_{datetime.datetime.now():%Y%m%d_%H%M%S}.txt"
        )

    def save(self, role, text):
        self.history.append((role, text))
        with open(self.file, "a", encoding="utf-8") as f:
            f.write(f"{role}: {text}\n\n")

    def context(self):
        return "\n".join(f"{r}: {t}" for r, t in self.history[-10:])

# =========================================================
# CODEX CHAT UI
# =========================================================
class CodexChat:
    def __init__(self, root):
        self.root = root
        root.title("Codex Desktop")
        root.geometry("1100x750")

        self.templates = load_templates()
        self.session = ChatSession()

        bar = tk.Frame(root)
        bar.pack(fill=tk.X)

        self.template_var = tk.StringVar(value="Free Chat")
        ttk.Combobox(
            bar,
            values=list(self.templates.keys()),
            textvariable=self.template_var,
            state="readonly",
            width=30
        ).pack(side=tk.RIGHT, padx=5)

        self.console = scrolledtext.ScrolledText(root, font=("Consolas", 11))
        self.console.pack(fill=tk.BOTH, expand=True)

        self.input = tk.Text(root, height=4)
        self.input.pack(fill=tk.X)

        tk.Button(root, text="Send", command=self.send).pack(pady=5)

    # -----------------------------------------------------
    def send(self):
        user_text = self.input.get("1.0", tk.END).strip()
        self.input.delete("1.0", tk.END)
        if not user_text:
            return

        template = self.templates[self.template_var.get()]
        prompt = f"{template}\n{user_text}".strip()

        self.console.insert(tk.END, f"\nüë§ You:\n{prompt}\n\n")
        self.session.save("User", prompt)

        threading.Thread(
            target=self.run_codex,
            args=(prompt,),
            daemon=True
        ).start()

    # -----------------------------------------------------
    def run_codex(self, prompt):
        if not os.path.exists(CODEX_CMD):
            self.console.insert(
                tk.END,
                f"\n‚ùå codex.cmd not found at:\n{CODEX_CMD}\n"
            )
            return

        env = os.environ.copy()
        env["PATH"] = NODE_DIR + ";" + env.get("PATH", "")

        full_prompt = (
            "You are Codex CLI assistant.\n\n"
            f"{self.session.context()}\n\n"
            f"User:\n{prompt}"
        )

        proc = subprocess.Popen(
            [CODEX_CMD, full_prompt],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            env=env,
            creationflags=CREATE_NO_WINDOW
        )

        response = ""
        for line in proc.stdout:
            response += line
            self.console.insert(tk.END, line)
            self.console.see(tk.END)

        err = proc.stderr.read().strip()
        if err:
            self.console.insert(tk.END, f"\n‚ö† Codex error:\n{err}\n")

        self.session.save("Assistant", response)
        LONG_TERM_MEMORY.append({"role": "assistant", "text": response})
        save_memory(LONG_TERM_MEMORY)

# =========================================================
# ENTRY
# =========================================================
if __name__ == "__main__":
    root = tk.Tk()
    CodexChat(root)
    root.mainloop()
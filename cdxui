import os
import subprocess
import tkinter as tk
from tkinter import scrolledtext, ttk
import threading
import queue

# ---------------- USER HOME RESOLUTION ----------------
def resolve_user_home():
    username = os.getenv("USERNAME")
    if username:
        base = fr"C:\Users\{username}"
        if os.path.isdir(base):
            return base
        corp = fr"C:\Users\{username}.corp"
        if os.path.isdir(corp):
            return corp
    return os.getenv("USERPROFILE")

USER_HOME = resolve_user_home()

# ---------------- PATHS ----------------
CODEX_DIR = os.path.join(USER_HOME, ".codex")
NODE_DIR = os.path.join(USER_HOME, "tools", "nodejs")

def resolve_codex_cmd():
    paths = [
        os.path.join(NODE_DIR, "codex.cmd"),
        os.path.join(NODE_DIR, "node_modules", ".bin", "codex.cmd"),
    ]
    for p in paths:
        if os.path.exists(p):
            return p
    raise FileNotFoundError("codex.cmd not found")

CODEX_CMD = resolve_codex_cmd()

# ---------------- GUI ----------------
class CodexGUI:
    def __init__(self, root):
        self.root = root
        root.title("Codex GUI (Stable Mode)")
        root.geometry("900x600")

        self.output = scrolledtext.ScrolledText(root, wrap=tk.WORD)
        self.output.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        frame = tk.Frame(root)
        frame.pack(fill=tk.X, padx=10, pady=5)

        self.entry = tk.Entry(frame)
        self.entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))
        self.entry.focus()

        tk.Button(frame, text="Ask Codex", command=self.ask).pack(side=tk.RIGHT)

        self.q = queue.Queue()
        root.after(100, self.process_queue)

    def process_queue(self):
        try:
            while True:
                msg = self.q.get_nowait()
                self.output.insert(tk.END, msg)
                self.output.see(tk.END)
        except queue.Empty:
            pass
        self.root.after(100, self.process_queue)

    def ask(self):
        prompt = self.entry.get().strip()
        if not prompt:
            return

        self.entry.delete(0, tk.END)
        self.output.insert(tk.END, f"\nüßë You:\n{prompt}\n\nü§ñ Codex:\n")
        self.output.see(tk.END)

        threading.Thread(target=self.run_codex, args=(prompt,), daemon=True).start()

    def run_codex(self, prompt):
        try:
            env = os.environ.copy()
            env["CODEX_HOME"] = CODEX_DIR
            env["USERPROFILE"] = USER_HOME

            proc = subprocess.Popen(
                [CODEX_CMD, "run"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                env=env
            )

            proc.stdin.write(prompt)
            proc.stdin.close()

            for line in proc.stdout:
                self.q.put(line)

        except Exception as e:
            self.q.put(f"\n‚ùå Error: {e}\n")

# ---------------- ENTRY ----------------
if __name__ == "__main__":
    root = tk.Tk()
    CodexGUI(root)
    root.mainloop()